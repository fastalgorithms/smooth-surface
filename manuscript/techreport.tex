\documentclass[11pt]{article}

\usepackage[top=1.1in,bottom=1.1in,left=1.2in,right=1.2in]{geometry}
\geometry{letterpaper}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{float}
\usepackage[cmex10]{amsmath}
\numberwithin{equation}{section}

\usepackage{mathrsfs,amsthm}
\usepackage{color}
%\usepackage[scaled=.90]{helvet}

\usepackage[font=small]{caption}
\usepackage[font=footnotesize]{subcaption}


\usepackage{titlesec}
%\titleformat{\section}{\normalfont\sffamily\Large\bfseries}
%  {\thesection}{1em}{}
%\titleformat{\subsection}{\normalfont\sffamily\large\bfseries}
%  {\thesubsection}{1em}{}
%\titleformat{\subsubsection}{\normalfont\sffamily\bfseries}
%  {\thesubsubsection}{1em}{}
  
\titleformat{\section}{\normalfont\Large\bfseries}
  {\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}
  {\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\bfseries}
  {\thesubsubsection}{1em}{}
  
  
  
% \usepackage{newtxtext}
%\usepackage{newtxmath}
\usepackage{kpfonts}
\usepackage{bm}

\usepackage{isomath}
\newcommand{\vct}{\vectorsym}
\newcommand{\mtx}{\matrixsym}

\newcommand{\lp}{\left(}
\newcommand{\rp}{\right)}

\usepackage[sort&compress]{natbib}

\DeclareMathOperator\erf{Erf}
\DeclareMathOperator\Ei{Ei}
\DeclareMathOperator\indic{I}
\newcommand\bbR{\mathbb R}
\newcommand\bphi{\boldsymbol \phi}
\newcommand\brho{\boldsymbol \rho}
\newcommand\rect{\rm rect}
\newcommand\bx{\vct{x}}
\newcommand\by{\vct{y}}
\newcommand\ds{\boldsymbol ds}
\newcommand\bH{\boldsymbol H}
\newcommand\bF{\boldsymbol F}
\newcommand\bA{\boldsymbol A}
\newcommand\bJ{\boldsymbol J}
\newcommand\bj{\boldsymbol j}
\newcommand\bb{\boldsymbol b}
\newcommand\ba{\boldsymbol a}
\newcommand\bM{\boldsymbol M}
\newcommand\In{\operatorname{inc}}
\newcommand\Sc{\operatorname{scat}}
\newcommand\bn{\boldsymbol n}
\newcommand\br{\boldsymbol r}

\newcommand\bP{\boldsymbol P}
\newcommand\bN{\boldsymbol N}
\newcommand\bQ{\boldsymbol Q}
\newcommand\bX{\boldsymbol X}
\newcommand\bY{\boldsymbol Y}
\newcommand\bV{\boldsymbol V}
\newcommand\bu{\boldsymbol u}
\newcommand\bv{\boldsymbol v}


%%\newcommand\tot{\operatorname{tot}}
\newcommand\tot{\operatorname{}}
%\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand{\cO}{\mathcal O}
\newcommand{\cC}{\mathcal C}
\newcommand{\cT}{\mathcal T}
\newcommand{\Vo}{\mathcal V_0}
\newcommand{\To}{\mathcal T_0}
\newcommand{\Vw}{\mathcal V_\omega}
\newcommand{\Tw}{\mathcal T_\omega}

\renewcommand{\phi}{\varphi}

\title{\bf{A Fast Boundary Integral Method
    for High-Order Mesh Generation}}

%\title{\bf\sffamily A Fast Algorithm to generate smooth 
%surfaces of arbitrary shape}

\author{Felipe Vico\thanks{Instituto de Telecomunicaciones y
    Aplicaciones Multimedia (ITEAM), 
    Universidad Polit\`ecnica
    de Val\`encia, 46022 Val\`encia, Spain.
    {\em Email}: \texttt{felipe.vico@gmail.com,}}, \,
Leslie Greengard\thanks{Courant Institute of Mathematical Sciences,
         New York University, 
         251 Mercer Street,
         New York, NY 10012.
{\em Email}: \texttt{greengard@cims.nyu.edu}. }, \, 
and Michael O'Neil\thanks{Courant Institute of Mathematical Sciences,
         New York University, 
         251 Mercer Street,
         New York, NY 10012.
{\em Email}: \texttt{oneil@cims.nyu.edu}. Research supported in part by
  the Office of Naval Research under award numbers
    \#N00014-17-1-2059 and \#N00014-17-1-2451.}}


\date{}



\begin{document}
\maketitle
%\tableofcontents
%\section{}
%\subsection{}




\begin{abstract}
  In this paper we present an algorithm to construct infinitely
  differentiable smooth surfaces of arbitrary shape.  The surfaces can
  have non-trivial genus and multi-scale details, and the algorithm
  used in generating them have computational complexity which is
  linear in the number of input~\emph{skeleton mesh elements}.  Using
  a convolution-like calculation, a level-set function~$\Phi$ is
  evaluated via convolution in~$\bbR^3$ of a volume indicator function
  with a smooth kernel.  Level sets of~$\Phi$ then define infinitely
  smooth surfaces, and with careful choice of the original skeleton,
  the~$\Phi=1/2$ surface is a \emph{smoothed} version of the original
  (possibly non-smooth) object.  Along the boundary of the object,
  flat regions and convexity are preserved, up to discretization
  error.  The bandlimit of the surface is locally controlled by the
  size of the input skeleton mesh and the (variable) width of the
  convolving kernel.  The volume convolution is accelerated by an
  application of the divergence theorem and a fast multipole method
  for the resulting boundary integral formulation.  We demonstrate the
  effectiveness and scaling of the algorithm using surface skeletons
  obtained from commercial CAD and meshing software.  Upon completion,
  the resulting smooth surface is described by an atlas which maps the
  original skeleton mesh to curvilinear triangles of arbitrarily high
  order.\\

  \noindent {\bf Keywords.} High-order surface discretization, level set,
  fast multipole method, mesh generation, boundary integrals.

\end{abstract}




\section{Introduction}

Integral equation methods for numerically solving many of the partial
differential equations (PDEs) of classical mathematical physics,
e.g. electromagnetics, fluid dynamics, heat flow, have greatly
advanced over the few decades along with advent of fast multipole
methods (FMMs)~\cite{song1997multilevel,coifman1993fast,tornberg-2008}. In
two dimensions, it is often the case that nearly machine precision
accuracy can be reached in solving these PDEs using integral equation
discretizations with a modest number of unknowns defined along
geometries which are defined to high-order, by either global
parameterizations or local piecewise-polynomial
parameterizations~\cite{helsing2015determination,helsing}. The
associated quadratures for the logarithmically singular Green's
functions are well-developed, and can be coupled with modern FMMs with
not much additional computational cost~\cite{hao_2014,rachh_2016}.
However, the story is still being developed in three dimensions, and
many details still need to be worked out.  While the three
dimensional fast algorithms (FMMs, etc.)  for computing the associated
$n$-body calculations are well-developed, quadratures for the
discretization of weakly-singular integral operators are much a work
in
progress~\cite{wala2018qbx,bremer-2015,bruno2001fast}. Surprisingly,
even with these limited tools, it is still possible to demonstrate
high-order convergence and nearly machine precision accuracy for solving
the PDEs of mathematical physics (using integral equation methods).
However, the geometries that can be
addressed are basically relegated to those that are globally
parameterizable: e.g. deformations of torii and
spheres~\cite{bremer-2015,oneil2018surface}.
The main impetus behind the quest for high-order
geometries and equally high-order solvers is one of reducing overall
computational cost; often is the case, particularly in high-frequency
wave propagation problems, that for the same overall accuracy
high-order methods require 
fewer flops per discretization point than do low-order methods.

The main roadblock to
obtaining high-order surface discretizations is the lack of meshing
algorithms which generate high-order curvilinear triangles or
quadrilateral patches.  One such software package that does offers this
desirable 
feature is Gmsh~\cite{gmsh}, but in order to do so it requires, upon
input, a computer aided drafting (CAD)-compatible
file describing the original geometry.  In the work of this paper, 
workflows such as that required for Gmsh are complemented
with an algorithm which can
bootstrap low-order \emph{skeleton} meshes, such as flat triangles, to
globally smooth high-order surfaces. The scheme proposed in this work
is able to accomplish such a result by formally using a global
convolution to define a level-set function, whose level-sets are
$C^\infty$ surfaces, and then \emph{locally} meshing the level-set to
any fixed, numerical precision.



The existing scheme of rounding corners of polygons, and edges and
corners polyhedra, in three dimensions
by Epstein and O'Neil~\cite{epstein_2016} can be considered the first
iteration of the algorithm in this work. In their work, the
observation was that if corners of a polygon~$P$ were viewed as
maps over the tangent line, convolution with a finite width
bell-function results in a smooth curve~$\gamma_{\text{loc}}$
which locally preserves
characteristics of the original polygon, such as convexity and large
flat regions. If the finite-width bell is
replaced with a Gaussian which has decayed to
size~$\epsilon$, then the resulting geometry is
an~$\epsilon$-approximation to a true $C^\infty$ curve.
This entire calculation is one-dimensional once the map
of the corner over the tangent line is calculated. Extending this
scheme, as is, to three dimensions is mathematically straightforward
but computationally and algorithmically slightly complicated by the
fact that many local maps have to be constructed, and then patched
together wherever there are edges or corners.

However, the scheme described above can be reformulated as a volume
convolution in which no local maps need to be constructed, only
evaluation of the indicator function of the region~$D$ bounded
by the polygon~$P$. While these two formulations are not
mathematically equivalent, much of their behavior is very similar.
The convolution of this indicator function
with a Gaussian defined in~$\bbR^2$ defines an infinitely
differentiable function~$\Phi = \Phi(x,y)$.
Furthermore, the curve $\gamma_{1/2}$ defined by the level
set $\Phi = 1/2$ is very close to the curve generated in the
original local convolution scheme,~$\gamma_{\text{loc}}$.
This second scheme, volume convolution and level-set tracing, extends
directly and \emph{easily} to three dimensions, both mathematically
and computationally (assuming that the indicator function can be
evaluated).
Additionally,  the resulting smooth geometry has a local dependency on the
skeleton (depending on the numerical support of the convolution
kernel), and therefore, if a small local change is made to the
skeleton, the smooth surface generated by the perturbed skeleton
remains unchanged at every point except for a neighborhood of the
perturbation.

There is a wide, expansive literature in the area of mesh generation,
mesh repair, efficient surface parameterization, etc. Most of the
existing work has been done in the area of computer vision or with
other computer science (or even data science) applications in mind
(i.e. fitting surfaces to point clouds, etc.). It would be impossible
to review the entire field here, but we will point out some important
works that are related and have inspired the current manuscript.

The algorithm of this paper can take, as input, a water-tight flat
triangulation of some underlying smooth surface and create an
infinitely smooth surface (and corresponding high-order triangulation)
which shares the qualitative features of the low-order flat
triangulation. This is not exactly a remeshing algorithm, but
certainly related. In~\cite{dapogny2014remesh}, the authors propose a
local method for mesh repair (adjusting size/aspect ratio of mesh
elements) based on a local interpolation and adjustment of control
points. This algorithm is able to generate very high-quality mesh
repairs, but is limited to curvilinear triangles of 2nd-order. To go
one-step further, there are many existing algorithms for constructing
surfaces not only from flat triangulations, but rather from merely
point clouds in~$\bbR^3$.  These methods include, most notably, moving
least squares surface reconstruction~\cite{fleishman2005}. This method
works as described, computing a smooth surface based on a local
least-squares approximation of the data, and also has the advantage of
being able to handle point clouds and triangulations that are noisy,
for example those obtained from three dimensional scanning devices. In
its current form, the algorithm of this paper does not handle this
regime, but extensions to noisy skeleton meshes are possible.

A class of algorithms that are related to the one presented in this
work, and introduced almost 30 years ago, is that of convolution
surfaces~\cite{bloomenthal1991,sherstyuk1999,sherstyuk1999design}.
Convolution surfaces were inspired by an earlier iteration of surface
construction used in molecular modeling and animation based on
computing iso-potential surfaces from point
sources~\cite{blinn1982}. Convolution surfaces generate an implicit
surface by computing the convolution of a radially symmetric Gaussian
kernel with the characteristic function of \emph{the surface}. The
algorithm of our paper instead computes the convolution of a Gaussian
with the characteristic function of \emph{the volume}, which has many
desirable properties over the latter. Furthermore, out algorithm has
an adaptive version in which the level sets are not computing via
convolution anymore, but rather via integration of a variable-width
Gaussian, a completely novel scheme which allows for fine-scale
structure in the skeleton mesh.  Sub-division
surfaces~\cite{derose1998subdivision,zorin1996interpolating} share
some elements in common with this earlier version of convolution
surfaces in that they are generated from some set of skeleton
points/lines/elements, A scheme presented in~\cite{ying2004simple}
constructs large parameterized patches from an initial skeleton
surface using piecewise maps and partitions of unity to blend them
together.



Lastly, it is important to point out the work that has been done in
the area of isogeometric analysis
(IGA)~\cite{cottrell,hughes2005isogeometric,simpson2014acoustic} with
regard to boundary element and boundary integral equation methods. IGA
is a framework for dealing directly with CAD geometries, and provides
a robust set of tools for surface refinement, manipulation, and
discretization. There have been several PDE and integral equation
solvers constructed based on IGA, and considerable progress has been
made toward coupling CAD systems with finite element methods. These
schemes are complementary to the one presented in this work, which
acts on an original low-order mesh, not the original CAD
geometry. Extending the ides of this manuscript to skeletons in
CAD-compatible formats is a work in progress.

The paper is organized as follows: In Section~\ref{sec:smooth} we lay
out the mathematical formulation, via convolution, of generating a
level-set which agrees qualitatively with an input skeleton mesh. This
requires convolution, constructing charts of elements, and a Newton
iteration.  Then, in Section~\ref{sec:algorithm} the surface
definitely in the previous section is reformulated in terms of a
boundary integral whose evaluation can be accelerated via a fast
multipole method.  Various aspects of the numerical implementation are
discussed. In Section~\ref{sec:adaptive}, an adaptive version of the
algorithm is developed to handle skeleton meshes with multiscale
features.  Section~\ref{sec:examples} contains several numerical
examples demonstrating the efficiency and behavior of our algorithm,
and concluding discussion is provided in
Section~\ref{sec:conclusions}.


\section{Smooth Surfaces via Convolution}
\label{sec:smooth}

The main mathematical observation of the algorithm presented in this
work is the following: the convolution of a piecewise function, $f$
(possibly discontinuous), with a $C^\infty$ kernel, $\phi$, results in
another $C^\infty$ function, $\Phi$. This fact is of course true in any
dimension, and in particular, if we define $\indic_V$ to be the
characteristic function of a closed and bounded
region~$V \subset \bbR^3$ with orientable surface~$S$, then
the convolution with a kernel~$\phi$ is given by
\begin{equation}
\begin{aligned}
\Phi(\bx) &= \int_{\bbR^3} \phi(\bx-\bx') \, \indic_\Omega(\bx') \, dv(\bx') \\
 &= \int_{V} \phi(\bx-\bx')  \, dv(\bx').
\end{aligned}
\end{equation}
Clearly, in order for the above formula to be numerically useful, it
is necessary to have a method for reliably evaluating $\indic_\Omega$
and for computing integrals of truncated $\phi$'s (for integrals
crossing the bounary of~$V$). The former can be
accomplished by obtaining a surface-conforming volume mesh of the
region~$V$ and the latter requires a quadrature for smooth
functions (e.g. polynomials) on each element of the volume mesh. The
level sets of~$\Phi$, $\Phi(\bx) = C$, then define smooth
surfaces~$\Gamma_C$ embedded in~$\bbR^3$.

If~$\phi$ is compactly supported and $\int \phi = 1$ then flat regions
of~$S$ which extend beyond the range of~$\phi$ are preserved
along the~$\Phi = 1/2$ level set, and~$\Gamma_C$ inherits the
regularity of~$\phi$. This can easily be shown in the
one-dimensional case~\cite{epstein_2016} and is straightforward to
show in higher dimensions. Furthermore, for compactly supported~$\phi$
the above convolution is a completely local calculation, and therefore
has optimal asymptotic computational scaling regardless of the
implementation. However, there is of course a tradeoff: kernels with
narrow support preserve small features of the domain~$V$ and its
boundary~$S$, and therefore may produce areas of high
curvature. Convolution with significantly wider kernels require a
significant increase in computational cost over the narrow case, as
well as resulting in overly smoothed surfaces.

With computational considerations in mind, one way to immediately
obtain a decrease in dimensionality of the previous calculation is the
following:
the above volume integral can be reformulated as a
boundary integral via an application of the divergence
theorem. If one can obtain a kernel~$\phi$ that is an exact
function, i.e.~$\phi = \nabla \cdot \vct{F}$ for some
vectorfield~$\vct{F}$, then we have that
\begin{equation}
  \begin{aligned}
    \Phi(\bx) &= \int_{V} \nabla_{\bx'} \cdot \vct{F}(\bx-\bx') \, dv(\bx') \\
    &= \int_{S} \bn(\bx') \cdot \vct{F}(\bx-\bx') \, da(\bx'),
  \end{aligned}
\end{equation}
where~$\bn(\bx')$ is the outward unit normal to the surface~$S$ at the
point~$\bx'$. The above formula is very useful in
designing a fast algorithm, but we will put it aside for now as it is
mathematically
equivalent to the volume calculation. We now turn to computing an
atlas (i.e. a collection of charts or parameterizations) describing the
convolution surface~$\Gamma_C$.





\subsection{Constructing an Atlas}

In what follows, the boundary~$S$ of the original volume~$V$ will be
referred to as the \emph{skeleton surface}. Often~$S$ will be supplied
as a low-order mesh (e.g. flat triangles), and will be assumed to be
water-tight and oriented (i.e. have a consistent collection of normal
vectors). This will be referred to as the \emph{skeleton mesh}.
The construction of the atlas will be described assuming an
initial collection of flat skeleton triangles, but is straightforward
to extend to other configurations (e.g. quadratic triangles, flat
quadrilaterals, etc.). To this end, the skeleton surface~$S$ is the
union of~$M$ triangles~$T^j$, $j=1,\ldots,M$, with each triangle
having vertices denoted
by~$\{ \vct{P}^j_1,\vct{P}^j_2,\vct{P}^j_3 \} $.
Therefore, each skeleton triangle can be parameterized as:
\begin{equation}
  \vct{T}^j(u,v) = \vct{P}^j_1 + u \lp \vct{P}^j_2 - \vct{P}^j_1 \rp
  + v \lp \vct{P}^j_3 - \vct{P}^j_1 \rp,
\end{equation}
and has Frenet basis defined by
\begin{equation}
\vct{T}^j_u = \vct{P}^j_2 - \vct{P}^j_1, \qquad
\vct{T}^j_v = \vct{P}^j_3 - \vct{P}^j_1, \qquad
\vct{N}^j =  \vct{T}^j_u \times \vct{T}^j_v.
\end{equation}
Note that the above basis along~$T^j$ is not an orthonormal one;
denote the normalized basis
by~$\hat{\vct{T}}^j_u$,~$\hat{\vct{T}}^j_v$,~$\hat{\vct{N}}^j$ (which
is comprised on unit vectors, but not orthogonal ones). Despite the
assumption of water-tightness on the skeleton mesh, the normal vectors
are obviously discontinuous across triangle edges. The following
construction of an atlas will be based on computing a mapping of each
skeleton triangle to a high-order curvilinear one along the
surface~$\Gamma_C$. In order to define a unique \emph{mapping
  direction} (since vectors along the normal direction will often
intersect at arbitrarily close locations to the skeleton mesh), we
define the vectorfield~$\vct{H}$ along the surface to be a local
averaging of the unit normal vectors~$\hat{\vct{N}}^j$.
We begin by defining~$\vct{H}$
at each of the vertices.  First, denote the list of triangles for
which~$\vct{P}^j_\ell$ is a common vertex by~$\cT \vct{P}^j_\ell$,
\begin{equation}
  \cT \vct{P}^j_\ell = \left\{ i \text{ such that } T^i \text{
      contains } \vct{P}^j_\ell \right\}.
\end{equation}
The value of the vectorfield~$\vct{H}$ at the vertex~$\vct{P}^j_\ell$
is then set to be
\begin{equation}
  \vct{H}^j_\ell = \frac{1}{
    \left|  \cT \vct{P}^j_\ell \right| } \sum_{i \in \cT
    \vct{P}^j_\ell} \hat{\vct{N}}^i,
\end{equation}
where~$|\mathcal A|$ denotes the cardinality of the set~$\mathcal A$.
The above is merely a local averaging of the normal vectors associated
with each triangle that shares~$\vct{P}^j_\ell$, and the
vector~$\vct{H}^j_\ell$ will be referred to as the \emph{vertex normal}
at~$\vct{P}^j_\ell$. This construction extends straightforwardly to
various other types of
skeleton patches; the vertex normal can, in general, be
defined as some weighted average of the normals of the adjacent triangles.
See Figure~\ref{normalvert1}. {\color{red} Update notation in Figure.}

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphics[width=\linewidth]{normal_vertex.png}%
    \caption{Vertex normal vector.}
    \label{normalvert1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphics[width=\linewidth]{normal_vertex_2.png}%
    \caption{Weighted vertex normal.}
    \label{normalvert2}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphics[width=\linewidth]{normal_vert_genus_2.pdf}%
    \caption{Skeleton and vertex normals.}
    \label{normalvert3}
  \end{subfigure}
  
  \caption{Construction of the vertex normals.}
  \label{fig:normalverts}
\end{figure}




One such reasonable choice of weighting is that of what we will refer
to as \emph{vertex angle}, not to be confused with the more commonly
used dihedral angle in geometry. The vertex angle of triangle~$T^j$
at vertex~$\vct{P}^j_\ell$ is merely the interior angle of the
triangle at this vertex. Depending on the behavior of~$S$ at the
vertex,
the total sum of all vertex angles of all adjacent triangles will be
different (i.e. if the surface is planar at~$\vct{P}^j_\ell$, the
total vertex angle is~$2\pi$).  Denote by $\theta^j_\ell$ the vertex angle of
triangle~$T^j$ at vertex~$\vct{P}^j_\ell$ and the total vertex angle
(sum of all vertex angles) by~$A^j_\ell$. The vertex normals can then
be computed using the vertex angle weighting as
\begin{equation}
  \vct{H}^j_\ell = \frac{1}{ A^j_\ell} \, 
  \sum_{i \in \cT \vct{P}^j_\ell} 
  \theta^j_\ell \,  \hat{\vct{N}}^i.
\end{equation}
See Figure~\ref{normalvert2}.
Along the interior of skeleton triangle~$T^j$, the
vectorfield~$\vct{H}$ is extended via convex combination:
\begin{equation}
  \vct{H}^j(u,v) = \vct{H}^j_1 + u \lp \vct{H}^j_2 - \vct{H}^j_1 \rp
  + v \lp \vct{H}^j_3 - \vct{H}^j_1 \rp.
\end{equation}
Note that this vectorfield is now continuous across the edges of each
skeleton triangle. See Figure~\ref{normalvert3}.

The convolution surface~$\Gamma_C$ (i.e. the level-set $\Phi = C$)
will be parameterized as a piecewise map above/below each skeleton
triangle in the direction~$\vct{H}$ as
\begin{equation}\label{eq:h}
  \vct{x}^j(u,v) = \vct{T}^j(u,v) + h^j(u,v) \, \vct{H}^j(u,v),
\end{equation}
with $\vct{x}^j$ denoting the chart which generates the patch~$\Gamma^j_C$
from the skeleton mesh. The function~$h^j$ can be determined
pointwise as the solution to the equation
\begin{equation}\label{eq:newton}
  \Phi\lp \vct{x}^j(u,v)  \rp - C = 0.
\end{equation}
The above is still an implicit definition of the surface, but for a
particular location~$(u,v)$ in parameter space, it can be solved
for~$h(u,v)$ relatively easily using Newton's method.
Newton's method also requires the
evaluation of the derivative of~$\Phi$, which in this case can be
computed as
\begin{equation}
  \begin{aligned}
  \frac{\partial \Phi}{\partial h} &= \frac{\partial }{\partial h}
  \int_V \phi\lp \vct{T} + h\, \vct{H} - \bx'\rp \, da(\vct{x}') \\
  &= \int_V \vct{H} \cdot \nabla \phi\lp
  \vct{T} + h\, \vct{H} - \bx'\rp \, da(\vct{x}'),
\end{aligned}
\end{equation}
where we have suppressed the dependence on the patch~$j$ and local
coordinates~$u,v$.  The final surface is obtained as the
collection of these charts~$\vct{x}^j$.  Each
chart~$\vct{x}^j:T_0 \to \bbR^3$ is smooth, and inherits the
regularity properties of the convolution kernel~$\phi$. Here,~$T_0$
denotes the standard simplex triangle $0 \leq u+v \leq 1$ with
$u,v >0$.



\begin{figure}[t]
  \centering
  \includegraphics[width=.65\linewidth]{normal_vertex_3.png}%
  \caption{The interpolated value of the vertex normal to the interior
    of the triangle.}
  \label{normalvert3}
\end{figure}




% Let's consider a Gaussian function of 3 variables:
% $k(\bx)=\frac{1}{\sigma^3\sqrt{2\pi}^3}e^{-\frac{r^2}{2\sigma^2}}$,
% where $r=|\bx|$ and $\bx\subset \mathbb{R}^3$. For the moment we will
% consider $\sigma$ as a constant.  Let's define the convolution of the
% indicator function on $\mathit{V}$ and the Gaussian:
% $$f(\bx)=\int_{V}k(\bx-\by)dV_{\by}$$
% Now we define the surface $\mathcal{S}=\{\bx \mid f(\bx)=\frac{1}{2}\}$.

% For a suitable selection of the parameter $\sigma$ (small enough), the
% resulting surface $\mathcal{S}$ is a smooth version of $\mathit{S}$,
% of class $C^{\infty}$. Notice also that we can control the degree of
% smoothness obtained by changing the value of the parameter
% $\sigma$. For $\sigma \rightarrow 0$, the surface obtained converges
% to the original skeleton $\mathcal{S}\rightarrow \mathit{S}$.

% Notice also that we can generalize this process to any skeleton
% $\mathit{S}$ (not only triangulated surfaces), and the same regularity
% on $\mathcal{S}$ will be obtained.








\subsection{Local Coordinates}
\label{sec:local}

In this section we find suitable expressions to obtain a local
 basis along each patch of the surface~$\Gamma^j$, as well
as the area element.
Recall that the chart for the patch~$\Gamma^j$ is given by
\begin{equation}\label{chart}
    \vct{x}^j(u,v) = \vct{T}^j(u,v) + h^j(u,v) \, \vct{H}^j(u,v).
\end{equation}
Taking the partial derivative with respect to~$u$ above, we have
\begin{equation}\label{u_vector}
  \begin{aligned}
    \vct{x}^j_u(u,v) &=  \frac{\partial \vct{x}^j}{\partial u}(u,v) \\
    &= \vct{T}^j_u + h^j(u,v) \,
  \vct{H}^j_u   + \frac{\partial h^j}{\partial
    u}(u,v)
  \, \vct{H}^j(u,v).
  \end{aligned}
\end{equation}
where the only unknown term is~$\partial h^j / \partial u$ (since it was
only~$h$ that was computed via Newton's algorithm, as in the previous
section).
However, using the fact that~$\partial\vct{x}^j/\partial u$ must be
tangent to the surface~$\Gamma_C$, and that~$\nabla \Phi$ is normal
to~$\Gamma$ (easily shown from computation), we have
\begin{equation}\label{U_vector_2}
  \frac{\partial h^j}{\partial u} = \frac{\lp \vct{T}^j_u + h^j \, \vct{H}^j_u
  \rp \cdot \nabla \Phi }{\vct{H}^j \cdot \nabla \Phi}.
\end{equation}
A similar calculation can be used to obtain
\begin{equation}\label{v_vector}
    \vct{x}^j_v
    = \vct{T}^j_v + h^j \,
  \vct{H}^j_v   + \frac{\partial h^j}{\partial
    v}
  \, \vct{H}^j
\end{equation}
with
\begin{equation}\label{v_vector_2}
  \frac{\partial h^j}{\partial v} = \frac{\lp \vct{T}^j_v + h^j \,
    \vct{H}^j_v
  \rp \cdot \nabla \Phi }{\vct{H}^j \cdot \nabla \Phi}.
\end{equation}
The area element along~$\Gamma^j_C$ is then easily computed as
\begin{equation}\label{eq:da}
 da = \left| \bx^j_u \times \bx^j_v \right| \, du \, dv.
\end{equation}
The normal vector along the surface can be calculated
as~$\nabla \Phi$.

We now turn to describing a fast high-order algorithm for numerically
approximating the surface~$\Gamma_C$ that is compatible with standard
boundary integral equation discretization schemes.








\section{A Fast Algorithm}
\label{sec:algorithm}

The previous discussion mostly omitted any numerical
considerations. In order to make the scheme as described a viable
numerical method, several elements have to be made computationally
tractable: for example, numerical evaluation of ~$\Phi$ (a volume
integral), approximation/discretization of the surface~$\Gamma_C$, and
implementation of Newton's method to determine the function~$h$
in~\eqref{eq:h}.
We begin by reformulating the expression for~$\Phi$ in terms of a
boundary integral, thereby obviating the need to mesh the interior
volume of the region~$V$.


\subsection{Boundary Integral Formulation}
\label{sec:bif}

Until this point, the convolution kernel~$\phi$ has not been
specified, aside from suggestions that certain advantages come from it
being compactly supported. In applications such as this, where
convolution is being used as a method to generate what we could call a
\emph{bandlimited surface}, there are two natural choices: a Gaussian
and the Kaiser-Bessel window~\cite{barnett2018}. In this work we
choose to use a Gaussian as the convolution kernel for various
reasons, namely for the ease with which the divergence theorem can be
applied to the volume convolution. The following identity allows us to
directly represent~$\Phi$ as a boundary integral: 
\begin{equation}
  \Delta \lp \frac{1}{4\pi |\bx|} \erf \lp \frac{|\bx|}{\sqrt{2}\sigma} \rp
  \rp = - \frac{1}{\lp 2\pi \sigma^2 \rp^{3/2}} e^{-|\bx|^2/2\sigma^2},
\end{equation}
where~$\erf$ is defined to as the integral of the Gaussian:
\begin{equation}
\erf(r) = \frac{2}{\sqrt{\pi}} \int^r_0 e^{-t^2} \, dt.
\end{equation}
Using the above identity, we can rewrite~$\Phi$ as
\begin{equation}\label{eq:surf}
  \begin{aligned}
    \Phi(\vct{x}) &= \int_V \frac{1}{\lp 2\pi \sigma^2 \rp^{3/2}}
    e^{-|\vct{x}-\vct{x}'|^2/2\sigma^2} \, dv(\vct{x}') \\
    &= - \int_V \Delta \lp \frac{1}{4\pi |\vct{x}-\vct{x}'|}
    \erf \lp \frac{|\vct{x} - \vct{x}'|}{\sqrt{2}\sigma} \rp
    \rp \, dv(\vct{x}') \\
    &= - \int_S \hat{\vct{N}}(\bx') \cdot \nabla_{\bx'}
     \lp \frac{1}{4\pi |\vct{x}-\vct{x}'|}
    \erf \lp \frac{|\vct{x} - \vct{x}'|}{\sqrt{2}\sigma} \rp
    \rp \, ds(\vct{x}') \\
    &=- \int_S  \hat{\vct{N}}(\vct{x}') \cdot \lp \vct{x} -\vct{x}' \rp \lp
    \frac{\erf \lp |\bx-\bx'|/ \sqrt{2}\sigma \rp
    }{4\pi|\bx-\bx'|^3}
    -\frac{\sqrt{\frac{2}{\pi}}e^{-|\bx-\bx'|^2/2\sigma^2}}{4\pi\sigma|\by-\bx|^2}
    \rp \, da(\bx') \\
    &= \int_S \psi(\bx-\bx') \, da(\bx').
  \end{aligned}
\end{equation}
Note that the kernel in the above surface integral, denoted by~$\psi$,
is smooth. Furthermore, for even modestly large values of~$r$, we have
that
\begin{equation}
  \erf(r) \approx 1, \qquad e^{-r^2} \approx 0.
\end{equation}
This means that in the far-field we can approximate the kernel~$\psi$ as
\begin{equation}
  \psi(\bx-\bx') \approx -\hat{\vct{N}}(\bx') \cdot \nabla_{\bx'} \left(
    \frac{1}{4\pi |\bx-\bx'| }\right).
\end{equation}
The above approximation is the same as the kernel appearing in
double-layer potentials when solving Laplace's equation in three
dimensions using integral equation methods. This type of kernel admits
very efficient, asymptotically optimal~$n$-body summations via fast
multipole methods~\cite{greengard-1997}, and therefore the resulting
boundary integral in~\eqref{eq:surf} can be applied efficiently.  For
a given target location~$\bx$, the surface integral above can be split
into two pieces:
\begin{equation}
  \Phi(\bx) \approx -\int_{S\setminus B(\bx,R)} \hat{\vct{N}}(\bx')
  \cdot \nabla_{\bx} \left(
    \frac{1}{4\pi |\bx-\bx'| }\right) \, da(\bx') +
  \int_{S \cap B(\bx,R)} \psi(\bx-\bx') \, da(\bx'),
\end{equation}
where~$R$ is chosen such that~$\Phi(\bx)$ is computed to some
specified accuracy~$\epsilon$. The first term above (the far-field)
can be discretized and computed using an FMM for Laplace potentials;
the second term can be discretized using quadratures for smooth
functions and computed directly, without the aid of any fast algorithm.
It easy to check that the gradient of the above expression can also be
efficiently evaluated using an FMM, as the gradient of the far-field
term is also a Laplace potential. The gradient can be expanded as:
\begin{equation}\label{eq:surfgrad}
    \nabla \Phi(\bx) =  ...
\end{equation}
{\color{red} Sign check and insert correct formula above.}
% \begin{equation}\label{surf_nablaf}
% \begin{aligned}
%   \nabla f(\bx)&=\int_{\mathit{S}}\nabla_{\bx}\nabla_{\by}\Big(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma}\big)}{4\pi|\by-\bx|}\Big)\cdot\bn(\by)dS_{\by}=\\
%   &=\int_{\mathit{S}}-\bn(\by)\Bigg(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma}\big)}{4\pi|\by-\bx|^3}-\frac{\sqrt{\frac{2}{\pi}}e^{-\frac{|\by-\bx|^2}{2\sigma^2}}}{4\pi\sigma|\by-\bx|^2}\Bigg)dS_{\by}+\\
%   +&\int_{\mathit{S}}
%   -\frac{e^{-\frac{r^2}{2\sigma^2}}(\sqrt{2}r^3+\sqrt{2}r\sigma^23)-\sigma^3\sqrt{\pi}3\erf{\big(\frac{r}{\sqrt{2}\sigma}}\big)}{r^5\sigma^3\pi^{3/2}4}(\bx-\by)<(\by-\bx)\cdot
%   \hat{\bn}(\by)>dS_{\by}
% \end{aligned}
% \end{equation}
%where $r=|\bx-\by|$. In this case we also have that, for far distances
%between source and target, we can approximate the kernel by:

% \begin{equation}
% \begin{aligned}
%   \nabla_{\bx}\nabla_{\by}\Big(\frac{\erf\big(\frac{|\by-\bx|}
% {\sqrt{2}\sigma}\big)}{4\pi|\by-\bx|}\Big)\cdot\bn(\by)\approx
%   \nabla_{\bx}\nabla_{\by}\Big(\frac{1}{4\pi|\by-\bx|}\Big)\cdot\bn(\by)
% \end{aligned}
% \end{equation}

% Which is the kernel of the gradient of the double layer with density
% $=1$, therefore we can use again the FMM to compute it. For the near
% interaction, the kernel is again smooth.

With the above reformulation of the evaluation of~$\Phi$ as a boundary
integral, and its calculation accelerated via an FMM, this means that
the Newton iteration for determining~$h$ in~\eqref{eq:newton} can be
performed \emph{simultaneously for every discretization point along
  $S$}. We now turn to the actual approximation of the
smoothed surface using high-order piecewise polynomial interpolation
and a discussion of the discretization of the above integrals.





\subsection{Discretization, Approximation, and the Newton
  Iteration}
\label{sec:disc}

In this section we describe a method for discretizing the surface
integral appearing in~\eqref{eq:surf} and subsequently approximating
the convolution surface~$\Gamma_C$ using a piecewise polynomial
approximation over the standard simplex triangle. Under our
assumption, the skeleton surface is provided as a collection of flat
triangles. In order to evaluate the boundary integral over this
surface with kernel~$\psi$, we discretize the integral on each
triangle using what are known as Vioreanu-Rokhlin
quadratures~\cite{vioreanu_2014}. These quadrature rules are very
efficient and are \emph{Gaussian-like} in that they integrate more
functions than there are nodes in the quadrature. The actual order of
the quadrature varies with the order of the underling implied
interpolation, see~\cite{vioreanu_2014} for details.
On the simplex~$T_0$, we
denote a polynomial of degree~$p$ in two variables as
\begin{equation}
  f(u,v) = \sum_{m+n \leq p} a_{mn} \, u^m \, v^n.
\end{equation}
The polynomial~$f$ above is said to be of total degree~$p$ and its
expansion has~$(p+1)(p+2)/2$ linearly independent polynomials.  For
example, Vioreanu-Rokhlin quadratures on the simplex for~$p=4$ have
$15=(4+1)(4+2)/2$ nodes and integrate exactly all polynomials in~$u,v$
with total degree~$q=7$ (i.e. 36 functions). When necessary, we report the
number of points in the Vioreanu-Rokhlin quadrature rule instead of
the ultimate order.
We will denote by~$n_p$ the number of polynomials of total degree less
than or equal to~$p$,~$n_p = (p+1)(p+2)/2$.

To this end, each skeleton triangle is discretized using an
$n_q$-point Vioreanu-Rokhlin quadrature scheme with nodes~$\{
u_k,v_k\}$ and weights~$\{ w_k \}$ on~$T_0$, the parameterization
domain.
This replaces the surface integral representation for~$\Phi$ with the
discrete sum
\begin{equation}
  \Phi(\bx) \approx \sum_{j = 1}^M \sum_{k = 1}^{n_q} w_k \, \psi \lp
  \bx-\vct{T}^j(u_k,v_k)\rp \, \left| \vct{N}^j(u_k,v_k) \right|.
\end{equation}
The discretization above is independent of the target point~$\bx$
because the integrand is smooth.  The target points will eventually,
after the Newton iteration has converged, lie on the
surface~$\Phi = C$. Denoting by~$p$ the ultimate order of the
approximation of the piecewise patches~$\Gamma^j$, for a given
function~$h$ we construct the image of~$n_p$ Vioreanu-Rokhlin nodes
along~$\Gamma^j$ as
\begin{equation}
  \bx^j_i = \vct{T}^j(u_i,v_i) + h^j(u_i,v_i) \, \vct{H}^j(u_i,v_i),
  \qquad \text{for } i = 1,\ldots,n_p.
\end{equation}
Via interpolation, the collection of points~$\bx^j_i$ defines a
curvilinear triangle of degree~$p$. I.e., the patch~$\Gamma^j$ has
been approximately parameterized as
\begin{equation}
  \vct{\Gamma}^j(u,v) \approx \sum_{m+n \leq p}^p \alpha_{mn} \, u^m
  \, v^n.
\end{equation}
Using the expressions of Section~\ref{sec:local}, once Newton's method
has converged the local coordinate system and metric tensor along the
surface (with respect to local parameterizations over~$T_0$) can be
calculated. This avoids numerical or spectral differentiation of the
above formula.
Note that the order of the quadrature along~$S$ and the order~$p$ of
the approximation of~$\Gamma^j$ are \emph{independent}. Often it will
be useful to use a very high order rule for discretization the
boundary integral representation of~$\Phi$ and a modest order of
approximation, e.g. 2, 4, or 6, for the level set.

With this formulation and parameterization laid out, we now turn to
the details of the Newton iteration used to locate points on the
surface~$\Phi = C$.  For notational purposes,
let~$h_{ji} = h^j(u_i,v_i)$ and~$h^{(k)}_{ji}$ be the~$k$th iterate of
$h_{ji}$ in Newton's method. For a particular skeleton triangle~$T^j$
and node $(u_i,v_i)$, we wish to find a root of the equation
\begin{equation}\label{newtoneq}
  \begin{aligned}
    f(h_{ji}) &= \Phi(\bx^j_i) - C \\
    &= \Phi\lp \vct{T}^j(u_i,v_i) + h_{ji} \, \vct{H}^j(u_i,v_i)
    \rp - C.
\end{aligned}
\end{equation}
This is an equation in one variable that can be solved using the a
simple one-dimensional Newton's method iteration.
Each evaluation of the function~$f$ requires the evaluation of a
boundary integral, however, an FMM can be used to compute~$\Phi$ at
\emph{all} points~$\bx^j_i$, for all $i$ and~$j$, in time proportional
to~$\cO \lp (n_p+n_q)M \rp$, i.e. linear in the total number of
targets and sources (discretization points).  Each of the Newton
iterations for~$h_{ji}$ are one-dimensional, and independent; the
evaluation of~$f$ and~$f'$ are merely accelerated using an
FMM. Expressions for~$f$ and~$f'$ above can be derived using
expressions for~$\Phi$ and $\nabla \Phi$ from the previous section.
The Newton iterations can be stopped once $|f| < \epsilon$ for all
$i$~and~$j$.





\subsection{Refinement}

In this section we describe the process to obtain a refined version of the discretization. The process consist of splitting each curved triangle  $\mathcal{T}_j$ of the original chart into four triangles, and then apply the discretization process described in section \ref{disc} to each sub-triangle.

Each chart of $\mathcal{T}_j$ can be written as:

\begin{equation}
\bY(u,v)=\bX(u,v)+\bV(u,v)h(u,v)
\end{equation}

For $(u,v)$ in the unitary triangle $0\le u, 0\le v, u+v\le1$ and $h(u,v)$ verifying the equation:

\begin{equation}
f(\bX(u,v)+\bV(u,v)h(u,v))=\frac{1}{2}
\end{equation}

Now we consider four subdomains of the unitary triangle as shown in the figure \ref{refinement1}:

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{Triangle_Refine_v2.pdf}
\end{center}
\caption{Description of the refinement process, nested triangles obtained on the canonical triangle and quadrature nodes obtained after refinement}
\label{refinement1}
\end{figure}

Notice that the definition of the surface $\mathcal{S}$ has not changed, as the function $f$ only depends on the skeleton $\mathit{S}$ and the parameter $\sigma$. Notice also that each triangle $\mathcal{T}_j$ has been split into four nested subtriangles $\mathcal{T}_j^1,\mathcal{T}_j^2,\mathcal{T}_j^3,\mathcal{T}_j^4$. See figure \ref{refinement2} and \ref{refinement3}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{cloud_points_refinement_v2.pdf}%
\end{center}
\caption{Description of the refinement process, nested triangles obtained}
\label{refinement2}
\end{figure}


\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{cloud_points_refinement_g2_v2.pdf}%
\end{center}
\caption{Description of the refinement process, nested triangles obtained}
\label{refinement3}
\end{figure}


By doing this we obtain a new atlas with four times more triangles:
$\{\mathcal{T}_j\}_{j=1}^{n_{tri}}\rightarrow
\{\mathcal{T}_j\}_{j=1}^{4\cdot n_{tri}}$ where we can apply the
discretization process of section \ref{disc} and obtain a discretized
surface with four times more points.








\section{A Fast Adaptive Algorithm}
\label{sec:adaptive}

So far we have described how to generate an infinitely smooth surface
from a closed flat triangulated skeleton surface~$S$. For any value
of~$\sigma$ in the smoothing kernel~$\phi$ the surface inherits the
regularity of~$\phi$. However, the actual magnitude of the values of
curvature and higher derivatives of the surface directly depend on the
magnitude of~$\sigma$; ideally the smooth surface should in some way
respect the behavior of the underlying skeleton (even though it may be
piecewise linear). In practice, when using a Gaussian smoothing
kernel, a typical value of~$\sigma$ which produces reasonable results
(heuristically) is~$\sigma \approx D/5$, where~$D$ is the local
diameter of triangles of the skeleton mesh. When~$\sigma$ is much
smaller than this, edges of skeleton mesh start to appear in the
smooth surface; when~$\sigma$ is too large, all features of the
skeleton mesh are convolved away.

In order to apply the algorithm of this manuscript to skeleton meshes
which have multiscale features, a convolution kernel must be used that
locally adapts to triangle sizes (diameters).
That is, if the skeleton mesh contains fine-scale features in a
certain region (and has equally small mesh elements in that region),
then the width~$\sigma$ of the smoothing kernel should be scaled down
so as not to wash away the structure. This means that the
kernel~\emph{cannot} be merely a function of~$\bx-\bx'$, and therefore
cannot be a true convolution.
In the adaptive case,
we propose to use the following kernel to construct the level-set
function~$\Phi_\ell$:
\begin{equation}
  \phi_\ell(\bx,\bx') = \frac{1}{\lp 2\pi \sigma(\bx)^2 \rp^3/2}
  e^{-|\bx-\bx'|^2/2\sigma(\bx)^2},
\end{equation}
where the function~$\sigma$ will be constructed below to adapt to the
scale of the skeleton mesh and the subscripts~$\ell$ denote
\emph{local}. The dependence of~$\sigma$ on the target~$\bx$ and not
the source~$\bx'$ is chosen so as to make the kernel compatible with
fast multipole methods in the far-field.


The function $\sigma(\bx)$ is a $C^{\infty}(\mathbb{R}^3)$ with a value at $\bx$ approximately proportional to the size of the nearest triangle. Next we propose two possibilities (see (\ref{sigma1}) and (\ref{sigma2})):

\begin{equation}\label{sigma1}
\sigma(\bx)=\frac{\sum_{j=1}^{n_{tri}}\sigma_je^{- \frac{|\bx-\bP_j^c|^2}{2\sigma^2_0}}}{\sum_{j=1}^{n_{tri}}e^{-\frac{|\bx-\bP_j^c|^2}{2\sigma^2_0}}}
\end{equation}

Here $\bP_j$ is the center of the $j$'th triangle of the skeleton $\mathit{S}$ and $\sigma_j$ are numbers proportional to the size of the $j$'th triangle of the skeleton. $\sigma_0$ is a parameter provided by the user, typically on the order of the average size of the triangles. Notice that if $\sigma_0\rightarrow \infty$ then $\sigma(\bx)$ is the averaged value of $\sigma_j$; if $\sigma_0\rightarrow 0$ then $\sigma(\bx)$ tend to the value of $\sigma_j$ of the nearest triangle with center at $\bP_j$.

Notice that the expression (\ref{sigma1}) can be computed as a quotient of two Gauss transforms, therefore, a fast algorithm is possible (see [Greengard Fast Gauss Transform]). In this case we are typically in a regime where only the loca interaction is required.

The definition of $\sigma(\bx)$ specified in (\ref{sigma1}) does not achieve perfect adaptivity across a high range of multiscale features. It only achieves some adaptivity across features of the geometry that differ by one order of magnitude in size. If further adaptivity is required (across several orders of magnitude) then we need a more complicated definition of $\sigma(\bx)$ for each fixed value of $\bx$ where we need to evaluate $\sigma(\bx)$ (see \ref{sigma2} and notice that the function $h(z)$ depends also on $\bx$):

\begin{equation}\label{sigma2}
\sigma(\bx)=\frac{\sum_{j=1}^{n_{tri}}\sigma_je^{-\frac{|\bx-\bP_j^c|^2 \lambda^2}{2\sigma^2(\bx)}}}{\sum_{j=1}^{n_{tri}}e^{-\frac{|\bx-\bP_j^c|^2 \lambda^2}{2\sigma^2(\bx)}}}
\end{equation}

Notice that, in this case, we have $\sigma(\bx)$ written in a implicit way. We can consider that $\sigma(\bx)$ is the fixed point of the function $h(z)$ with $z=\sigma(\bx)$, where:

\begin{equation}\label{sigma2}
h(z)=\frac{\sum_{j=1}^{n_{tri}}\sigma_je^{-\frac{|\bx-\bP_j^c|^2 \lambda^2}{2z^2}}}{\sum_{j=1}^{n_{tri}}e^{-\frac{|\bx-\bP_j^c|^2 \lambda^2}{2z^2}}}
\end{equation}

This makes the calculation a bit more complicated, yet we can evaluate it by using an iterative method. To make it more stable we propose to use the relaxation method with $\eta=0.2$ on the first 10 iterations (that is to iterate with $z_{n+1}=\eta h(z_n)+(1-\eta)z_n$) and then use the Newton method for the function $h(z)-z=0$. An appropriate intial guess for $\sigma(\bx)=\sigma_0(\bx)$ is given by the expression \ref{sigma1} with a choice of $\sigma_0$ proportional to the size of the smallest triangle :
 
\begin{equation}\label{sigma0}
\sigma_0(\bx)=\frac{\sum_{j=1}^{n_{tri}}\sigma_je^{- \frac{|\bx-\bP_j^c|^2}{2\sigma^2_1}}}{\sum_{j=1}^{n_{tri}}e^{-\frac{|\bx-\bP_j^c|^2}{2\sigma^2_1}}}
\end{equation}









In the adaptive case, we can still evaluate the function $f(\bx)$ and
$\nabla f(\bx)$ efficiently using the FMM. Next we update the
expressions~\ref{eq:surf} and \ref{surf_nablaf} for the variable
$\sigma(\bx)$ case:

 
\begin{equation}
\begin{aligned}
f(\bx)&=\int_{\mathit{S}}\nabla_{\by}\Big(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma(\bx)}\big)}{4\pi|\by-\bx|}\Big)\cdot\bn(\by)dS_{\by}=\\
&=\int_{\mathit{S}}\Bigg(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma(\bx)}\big)}{4\pi|\by-\bx|^3}-\frac{\sqrt{\frac{2}{\pi}}e^{-\frac{|\by-\bx|^2}{2\sigma^2(\bx)}}}{4\pi\sigma(\bx)|\by-\bx|^2}\Bigg)(\by-\bx)\cdot\bn(\by)dS_{\by}
\end{aligned}
\end{equation}

\begin{equation}
\begin{aligned}
\nabla f(\bx)&=\int_{\mathit{S}}\nabla_{\bx}\nabla_{\by}\Big(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma(\bx)}\big)}{4\pi|\by-\bx|}\Big)\cdot\bn(\by)dS_{\by}=\\
&=\int_{\mathit{S}}-\bn(\by)\Bigg(\frac{\erf\big(\frac{|\by-\bx|}{\sqrt{2}\sigma(\bx)}\big)}{4\pi|\by-\bx|^3}-\frac{\sqrt{\frac{2}{\pi}}e^{-\frac{|\by-\bx|^2}{2\sigma^2(\bx)}}}{4\pi\sigma(\bx)|\by-\bx|^2}\Bigg)dS_{\by}-\\
-&\int_{\mathit{S}} \frac{e^{-\frac{r^2}{2\sigma^2(\bx)}}(\sqrt{2}r^3+\sqrt{2}r\sigma^2(\bx)3)-\sigma^3(\bx)\sqrt{\pi}3\erf{\big(\frac{r}{\sqrt{2}\sigma(\bx)}}\big)}{r^5\sigma(\bx)^3\pi^{3/2}4}(\bx-\by)<(\by-\bx)\cdot \hat{\bn}(\by)>dS_{\by}+\\
+&\int_{\mathit{S}} \frac{e^{-\frac{r^2}{2\sigma^2(\bx)}}}{\sigma^4(\bx)\pi^(3/2)2\sqrt{2}}<(\by-\bx)\cdot \hat{\bn}(\by)>\nabla_{\bx}\sigma(\bx)dS_{\by}
\end{aligned}
\end{equation}

%\begin{equation}
%-\frac{e^{-\frac{r^2}{2\sigma^2}}(\sqrt{2}r^3+\sqrt{2}r\sigma^23)-\sigma^3\sqrt{\pi}3\erf{\big(\frac{r}{\sqrt{2}\sigma}}\big)}{r^5\sigma^3\pi^{3/2}4}
%\end{equation}
In this case we can also use the FMM to speed up this calculation.





\section{Numerical Examples}
\label{sec:examples}

\subsection{Basic Surface Generation}
\label{sec:basic}


\subsection{Recovery of a Sphere}
\label{sec:sphere}

Smooth a large polygon into a sphere, see how close it gets


\subsection{Large-scale Structures}
\label{sec:large}

Show the gun boat or jet



\subsection{Modes of Failure}
\label{sec:failure}

Show the ringing example when skelton mesh is too large




\section{Conclusions}
\label{sec:conclusions}



























\bibliographystyle{abbrv}
\bibliography{master}

  
\end{document}  